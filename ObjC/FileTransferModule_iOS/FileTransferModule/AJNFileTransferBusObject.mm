////////////////////////////////////////////////////////////////////////////////
//
//  ALLJOYN MODELING TOOL - GENERATED CODE
//
//  This is an autogenerated or copied file which the AllSeen Alliance
//  as author hereby dedicates to the public domain.  Additionally, THIS
//  SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND ANY CONTRIBUTORS "AS IS"
//  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE,
//  AND OF GOOD TITLE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
//  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
//  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
//  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
//  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
//  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
//  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
//  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
////////////////////////////////////////////////////////////////////////////////
//
//  DO NOT EDIT
//
//  Add a category or subclass in separate .h/.m files to extend these classes
//
////////////////////////////////////////////////////////////////////////////////
//
//  AJNFileTransferBusObject.mm
//
////////////////////////////////////////////////////////////////////////////////

#import <alljoyn/BusAttachment.h>
#import <alljoyn/BusObject.h>
#import "AllJoynFramework/AJNBusObjectImpl.h"
#import "AllJoynFramework/AJNInterfaceDescription.h"
#import "AllJoynFramework/AJNMessageArgument.h"
#import "AllJoynFramework/AJNSignalHandlerImpl.h"

#import "FileTransferBusObject.h"

using namespace ajn;


@interface AJNMessageArgument(Private)

/*
 * Helper to return the C++ API object that is encapsulated by this objective-c class
 */
@property (nonatomic, readonly) MsgArg *msgArg;

@end


////////////////////////////////////////////////////////////////////////////////
//
//  C++ Bus Object class declaration for FileTransferBusObjectImpl
//
////////////////////////////////////////////////////////////////////////////////
class FileTransferBusObjectImpl : public AJNBusObjectImpl
{
private:
    const InterfaceDescription::Member* dataChunkSignalMember;
	const InterfaceDescription::Member* stopDataXferSignalMember;
	const InterfaceDescription::Member* dataXferCancelledSignalMember;
	const InterfaceDescription::Member* announceSignalMember;
	const InterfaceDescription::Member* requestAnnouncementSignalMember;

    //TODO Workaround for the "AJNBusObjectImpl constructor requires a bus attachment" problem
    static BusAttachment& getDummyBusAttachment()
    {
        static BusAttachment* dummyBusAttachment = NULL;
        
        if (dummyBusAttachment == NULL)
        {
            dummyBusAttachment = new BusAttachment("");
        }
        
        return *dummyBusAttachment;
    }

public:
    FileTransferBusObjectImpl(const char *path, id<DataTransferDelegate, FileDiscoveryDelegate> aDelegate);

    FileTransferBusObjectImpl(BusAttachment &bus, const char *path, id<DataTransferDelegate, FileDiscoveryDelegate> aDelegate);

    virtual QStatus InitializeBusInterface(BusAttachment &bus);
    
    
    
    // methods
    //
    void requestData(const InterfaceDescription::Member* member, Message& msg);
	void requestOffer(const InterfaceDescription::Member* member, Message& msg);
	void offerFile(const InterfaceDescription::Member* member, Message& msg);

    
    // signals
    //
    QStatus SenddataChunk(MsgArg* fileID,int32_t startByte,int32_t chunkLength,MsgArg* chunk, const char* destination, SessionId sessionId, uint16_t timeToLive = 0, uint8_t flags = 0);
	QStatus SendstopDataXfer(MsgArg* fileID, const char* destination, SessionId sessionId, uint16_t timeToLive = 0, uint8_t flags = 0);
	QStatus SenddataXferCancelled(MsgArg* fileID, const char* destination, SessionId sessionId, uint16_t timeToLive = 0, uint8_t flags = 0);
	QStatus Sendannounce(MsgArg* fileList,bool isFileIDResponse, const char* destination, SessionId sessionId, uint16_t timeToLive = 0, uint8_t flags = 0);
	QStatus SendrequestAnnouncement( const char* destination, SessionId sessionId, uint16_t timeToLive = 0, uint8_t flags = 0);

};
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//  C++ Bus Object implementation for FileTransferBusObjectImpl
//
////////////////////////////////////////////////////////////////////////////////

FileTransferBusObjectImpl::FileTransferBusObjectImpl(const char *path, id<DataTransferDelegate, FileDiscoveryDelegate> aDelegate) : 
    AJNBusObjectImpl(getDummyBusAttachment(),path,aDelegate)
{
    // Intentionally empty
}

FileTransferBusObjectImpl::FileTransferBusObjectImpl(BusAttachment &bus, const char *path, id<DataTransferDelegate, FileDiscoveryDelegate> aDelegate) :
    AJNBusObjectImpl(bus,path,aDelegate)
{
    // Workaround for the "AJNBusObjectImpl constructor ignoring the bus attachment" problem
    this->bus = &bus;
    
    InitializeBusInterface(bus);
}

QStatus FileTransferBusObjectImpl::InitializeBusInterface(BusAttachment &bus)
{
    const InterfaceDescription* interfaceDescription = NULL;
    QStatus status;
    status = ER_OK;
    
    
    // Add the org.alljoyn.Cops.DataTransfer interface to this object
    //
    interfaceDescription = bus.GetInterface("org.alljoyn.Cops.DataTransfer");
    assert(interfaceDescription);
    status = AddInterface(*interfaceDescription);

    if (ER_OK != status) {
        NSLog(@"ERROR: An error occurred while adding the interface org.alljoyn.Cops.DataTransfer. %@", [AJNStatus descriptionForStatusCode:status]);
    }
    
    
    // Register the method handlers for interface DataTransferDelegate with the object
    //
    const MethodEntry methodEntriesForDataTransferDelegate[] = {

        {
			interfaceDescription->GetMember("requestData"), static_cast<MessageReceiver::MethodHandler>(&FileTransferBusObjectImpl::requestData)
		}
    
    };
    
    status = AddMethodHandlers(methodEntriesForDataTransferDelegate, sizeof(methodEntriesForDataTransferDelegate) / sizeof(methodEntriesForDataTransferDelegate[0]));
    if (ER_OK != status) {
        NSLog(@"ERROR: An error occurred while adding method handlers for interface org.alljoyn.Cops.DataTransfer to the interface description. %@", [AJNStatus descriptionForStatusCode:status]);
    }
    
    // save off signal members for later
    //
    dataChunkSignalMember = interfaceDescription->GetMember("dataChunk");
    assert(dataChunkSignalMember);    
stopDataXferSignalMember = interfaceDescription->GetMember("stopDataXfer");
    assert(stopDataXferSignalMember);    
dataXferCancelledSignalMember = interfaceDescription->GetMember("dataXferCancelled");
    assert(dataXferCancelledSignalMember);    

    // Add the org.alljoyn.Cops.FileDiscovery interface to this object
    //
    interfaceDescription = bus.GetInterface("org.alljoyn.Cops.FileDiscovery");
    assert(interfaceDescription);
    status = AddInterface(*interfaceDescription);

    if (ER_OK != status) {
        NSLog(@"ERROR: An error occurred while adding the interface org.alljoyn.Cops.FileDiscovery. %@", [AJNStatus descriptionForStatusCode:status]);
    }
    
    
    // Register the method handlers for interface FileDiscoveryDelegate with the object
    //
    const MethodEntry methodEntriesForFileDiscoveryDelegate[] = {

        {
			interfaceDescription->GetMember("requestOffer"), static_cast<MessageReceiver::MethodHandler>(&FileTransferBusObjectImpl::requestOffer)
		},

		{
			interfaceDescription->GetMember("offerFile"), static_cast<MessageReceiver::MethodHandler>(&FileTransferBusObjectImpl::offerFile)
		}
    
    };
    
    status = AddMethodHandlers(methodEntriesForFileDiscoveryDelegate, sizeof(methodEntriesForFileDiscoveryDelegate) / sizeof(methodEntriesForFileDiscoveryDelegate[0]));
    if (ER_OK != status) {
        NSLog(@"ERROR: An error occurred while adding method handlers for interface org.alljoyn.Cops.FileDiscovery to the interface description. %@", [AJNStatus descriptionForStatusCode:status]);
    }
    
    // save off signal members for later
    //
    announceSignalMember = interfaceDescription->GetMember("announce");
    assert(announceSignalMember);    
requestAnnouncementSignalMember = interfaceDescription->GetMember("requestAnnouncement");
    assert(requestAnnouncementSignalMember);    


    return status;
}


void FileTransferBusObjectImpl::requestData(const InterfaceDescription::Member *member, Message& msg)
{
    @autoreleasepool {
    
    
    
    
    // get all input arguments
    //
    
    AJNMessageArgument* inArg0 = [[AJNMessageArgument alloc] initWithHandle:(AJNHandle)new MsgArg(*(msg->GetArg(0))) shouldDeleteHandleOnDealloc:YES];        
        
    int32_t inArg1 = msg->GetArg(1)->v_int32;
        
    int32_t inArg2 = msg->GetArg(2)->v_int32;
        
    int32_t inArg3 = msg->GetArg(3)->v_int32;
        
    // declare the output arguments
    //
    
	NSNumber* outArg0;

    
    // call the Objective-C delegate method
    //
    
	outArg0 = [(id<DataTransferDelegate>)delegate requestDataWithFileID:inArg0 startByte:[NSNumber numberWithInt:inArg1] length:[NSNumber numberWithInt:inArg2] andMaxChunkLength:[NSNumber numberWithInt:inArg3] fromSender:[[[AJNMessage alloc] initWithHandle:&msg] senderName]];
            
        
    // formulate the reply
    //
    MsgArg outArgs[1];
    
    outArgs[0].Set("i", [outArg0 intValue]);

    QStatus status = MethodReply(msg, outArgs, 1);
    if (ER_OK != status) {
        NSLog(@"ERROR: An error occurred when attempting to send a method reply for requestData. %@", [AJNStatus descriptionForStatusCode:status]);
    }        
    
    
    }
}


QStatus FileTransferBusObjectImpl::SenddataChunk(MsgArg* fileID,int32_t startByte,int32_t chunkLength,MsgArg* chunk, const char* destination, SessionId sessionId, uint16_t timeToLive, uint8_t flags)
{

    MsgArg args[4];

    args[0] = *fileID;
            args[1].Set( "i", startByte );
        
            args[2].Set( "i", chunkLength );
        args[3] = *chunk;

    return Signal(destination, sessionId, *dataChunkSignalMember, args, 4, timeToLive, flags);
}


QStatus FileTransferBusObjectImpl::SendstopDataXfer(MsgArg* fileID, const char* destination, SessionId sessionId, uint16_t timeToLive, uint8_t flags)
{

    MsgArg args[1];

    args[0] = *fileID;

    return Signal(destination, sessionId, *stopDataXferSignalMember, args, 1, timeToLive, flags);
}


QStatus FileTransferBusObjectImpl::SenddataXferCancelled(MsgArg* fileID, const char* destination, SessionId sessionId, uint16_t timeToLive, uint8_t flags)
{

    MsgArg args[1];

    args[0] = *fileID;

    return Signal(destination, sessionId, *dataXferCancelledSignalMember, args, 1, timeToLive, flags);
}


void FileTransferBusObjectImpl::requestOffer(const InterfaceDescription::Member *member, Message& msg)
{
    @autoreleasepool {
    
    
    
    
    // get all input arguments
    //
    
    qcc::String inArg0 = msg->GetArg(0)->v_string.str;
        
    // declare the output arguments
    //
    
	NSNumber* outArg0;

    
    // call the Objective-C delegate method
    //
    
	outArg0 = [(id<FileDiscoveryDelegate>)delegate requestOfferWithFilePath:[NSString stringWithCString:inArg0.c_str() encoding:NSUTF8StringEncoding] fromSender:[[[AJNMessage alloc] initWithHandle:&msg] senderName]];
            
        
    // formulate the reply
    //
    MsgArg outArgs[1];
    
    outArgs[0].Set("i", [outArg0 intValue]);

    QStatus status = MethodReply(msg, outArgs, 1);
    if (ER_OK != status) {
        NSLog(@"ERROR: An error occurred when attempting to send a method reply for requestOffer. %@", [AJNStatus descriptionForStatusCode:status]);
    }        
    
    
    }
}


void FileTransferBusObjectImpl::offerFile(const InterfaceDescription::Member *member, Message& msg)
{
    @autoreleasepool {
    
    
    
    
    // get all input arguments
    //
    
    AJNMessageArgument* inArg0 = [[AJNMessageArgument alloc] initWithHandle:(AJNHandle)new MsgArg(*(msg->GetArg(0))) shouldDeleteHandleOnDealloc:YES];        
        
    // declare the output arguments
    //
    
	NSNumber* outArg0;

    
    // call the Objective-C delegate method
    //
    
	outArg0 = [(id<FileDiscoveryDelegate>)delegate offerFileWithFileDescriptor:inArg0 fromSender:[[[AJNMessage alloc] initWithHandle:&msg] senderName]];
            
        
    // formulate the reply
    //
    MsgArg outArgs[1];
    
    outArgs[0].Set("i", [outArg0 intValue]);

    QStatus status = MethodReply(msg, outArgs, 1);
    if (ER_OK != status) {
        NSLog(@"ERROR: An error occurred when attempting to send a method reply for offerFile. %@", [AJNStatus descriptionForStatusCode:status]);
    }        
    
    
    }
}


QStatus FileTransferBusObjectImpl::Sendannounce(MsgArg* fileList,bool isFileIDResponse, const char* destination, SessionId sessionId, uint16_t timeToLive, uint8_t flags)
{

    MsgArg args[2];

    args[0] = *fileList;
            args[1].Set( "b", isFileIDResponse );
        

    return Signal(destination, sessionId, *announceSignalMember, args, 2, timeToLive, flags);
}


QStatus FileTransferBusObjectImpl::SendrequestAnnouncement( const char* destination, SessionId sessionId, uint16_t timeToLive, uint8_t flags)
{

    MsgArg args[0];

    

    return Signal(destination, sessionId, *requestAnnouncementSignalMember, args, 0, timeToLive, flags);
}



////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//  Objective-C Bus Object implementation for AJNFileTransferBusObject
//
////////////////////////////////////////////////////////////////////////////////

@interface AJNFileTransferBusObject()

/**
 * The bus attachment this object is associated with.
 */
@property (nonatomic, weak) AJNBusAttachment *bus;

@end

@implementation AJNFileTransferBusObject

@dynamic handle;
@synthesize bus = _bus;



- (FileTransferBusObjectImpl*)busObject
{
    return static_cast<FileTransferBusObjectImpl*>(self.handle);
}

- (QStatus)registerInterfacesWithBus:(AJNBusAttachment *)busAttachment
{
    QStatus status;

    status = [self activateInterfacesWithBus: busAttachment];

    self.busObject->InitializeBusInterface(*((ajn::BusAttachment*)busAttachment.handle));
    
    return status;
}

- (QStatus)activateInterfacesWithBus:(AJNBusAttachment *)busAttachment
{
    QStatus status;

    status = ER_OK;
    
    AJNInterfaceDescription *interfaceDescription;
    
    
        //
        // DataTransferDelegate interface (org.alljoyn.Cops.DataTransfer)
        //
        // create an interface description, or if that fails, get the interface as it was already created
        //
        interfaceDescription = [busAttachment createInterfaceWithName:@"org.alljoyn.Cops.DataTransfer"];
        
    
        // add the methods to the interface description
        //
    
        status = [interfaceDescription addMethodWithName:@"requestData" inputSignature:@"ayiii" outputSignature:@"i" argumentNames:[NSArray arrayWithObjects:@"fileID",@"startByte",@"length",@"maxChunkLength",@"statusCode", nil]];
        
        if (status != ER_OK && status != ER_BUS_MEMBER_ALREADY_EXISTS) {
            @throw [NSException exceptionWithName:@"BusObjectInitFailed" reason:@"Unable to add method to interface: requestData" userInfo:nil];
        }

        // add the signals to the interface description
        //
    
        status = [interfaceDescription addSignalWithName:@"dataChunk" inputSignature:@"ayiiay" argumentNames:[NSArray arrayWithObjects:@"fileID",@"startByte",@"chunkLength",@"chunk", nil]];
        
        if (status != ER_OK && status != ER_BUS_MEMBER_ALREADY_EXISTS) {
            @throw [NSException exceptionWithName:@"BusObjectInitFailed" reason:@"Unable to add signal to interface:  dataChunk" userInfo:nil];
        }

        status = [interfaceDescription addSignalWithName:@"stopDataXfer" inputSignature:@"ay" argumentNames:[NSArray arrayWithObjects:@"fileID", nil]];
        
        if (status != ER_OK && status != ER_BUS_MEMBER_ALREADY_EXISTS) {
            @throw [NSException exceptionWithName:@"BusObjectInitFailed" reason:@"Unable to add signal to interface:  stopDataXfer" userInfo:nil];
        }

        status = [interfaceDescription addSignalWithName:@"dataXferCancelled" inputSignature:@"ay" argumentNames:[NSArray arrayWithObjects:@"fileID", nil]];
        
        if (status != ER_OK && status != ER_BUS_MEMBER_ALREADY_EXISTS) {
            @throw [NSException exceptionWithName:@"BusObjectInitFailed" reason:@"Unable to add signal to interface:  dataXferCancelled" userInfo:nil];
        }

    
        [interfaceDescription activate];

        //
        // FileDiscoveryDelegate interface (org.alljoyn.Cops.FileDiscovery)
        //
        // create an interface description, or if that fails, get the interface as it was already created
        //
        interfaceDescription = [busAttachment createInterfaceWithName:@"org.alljoyn.Cops.FileDiscovery"];
        
    
        // add the methods to the interface description
        //
    
        status = [interfaceDescription addMethodWithName:@"requestOffer" inputSignature:@"s" outputSignature:@"i" argumentNames:[NSArray arrayWithObjects:@"filePath",@"statusCode", nil]];
        
        if (status != ER_OK && status != ER_BUS_MEMBER_ALREADY_EXISTS) {
            @throw [NSException exceptionWithName:@"BusObjectInitFailed" reason:@"Unable to add method to interface: requestOffer" userInfo:nil];
        }

        status = [interfaceDescription addMethodWithName:@"offerFile" inputSignature:@"(ssssayi)" outputSignature:@"i" argumentNames:[NSArray arrayWithObjects:@"file",@"statusCode", nil]];
        
        if (status != ER_OK && status != ER_BUS_MEMBER_ALREADY_EXISTS) {
            @throw [NSException exceptionWithName:@"BusObjectInitFailed" reason:@"Unable to add method to interface: offerFile" userInfo:nil];
        }

        // add the signals to the interface description
        //
    
        status = [interfaceDescription addSignalWithName:@"announce" inputSignature:@"a(ssssayi)b" argumentNames:[NSArray arrayWithObjects:@"fileList",@"isFileIDResponse", nil]];
        
        if (status != ER_OK && status != ER_BUS_MEMBER_ALREADY_EXISTS) {
            @throw [NSException exceptionWithName:@"BusObjectInitFailed" reason:@"Unable to add signal to interface:  announce" userInfo:nil];
        }

        status = [interfaceDescription addSignalWithName:@"requestAnnouncement" inputSignature:@"" argumentNames:[NSArray arrayWithObjects: nil]];
        
        if (status != ER_OK && status != ER_BUS_MEMBER_ALREADY_EXISTS) {
            @throw [NSException exceptionWithName:@"BusObjectInitFailed" reason:@"Unable to add signal to interface:  requestAnnouncement" userInfo:nil];
        }

    
        [interfaceDescription activate];

    
    self.bus = busAttachment;

    return status;
}

- (id)initWithPath:(NSString *)path
{
    self = [super initWithPath:path];
    if (self) {

        // create the internal C++ bus object
        //
        FileTransferBusObjectImpl *busObject = new FileTransferBusObjectImpl([path UTF8String], (id<DataTransferDelegate, FileDiscoveryDelegate>)self);
        
        self.handle = busObject;
    }
    return self;
}

- (id)initWithBusAttachment:(AJNBusAttachment *)busAttachment onPath:(NSString *)path
{
    self = [super initWithBusAttachment:busAttachment onPath:path];
    if (self) {
        [self activateInterfacesWithBus: busAttachment];

        // create the internal C++ bus object
        //
        FileTransferBusObjectImpl *busObject = new FileTransferBusObjectImpl(*((ajn::BusAttachment*)busAttachment.handle), [path UTF8String], (id<DataTransferDelegate, FileDiscoveryDelegate>)self);
        
        self.handle = busObject;
    }
    return self;
}

- (void)dealloc
{
    FileTransferBusObjectImpl *busObject = [self busObject];
    delete busObject;
    self.handle = nil;
}

    
- (NSNumber*)requestDataWithFileID:(AJNMessageArgument*)fileID startByte:(NSNumber*)startByte length:(NSNumber*)length andMaxChunkLength:(NSNumber*)maxChunkLength fromSender:(NSString *)sender
{
    //
    // GENERATED CODE - DO NOT EDIT
    //
    // Create a category or subclass in separate .h/.m files
    @throw([NSException exceptionWithName:@"NotImplementedException" reason:@"You must override this method in a subclass" userInfo:nil]);
}

- (NSNumber*)requestOfferWithFilePath:(NSString*)filePath fromSender:(NSString *)sender
{
    //
    // GENERATED CODE - DO NOT EDIT
    //
    // Create a category or subclass in separate .h/.m files
    @throw([NSException exceptionWithName:@"NotImplementedException" reason:@"You must override this method in a subclass" userInfo:nil]);
}

- (NSNumber*)offerFileWithFileDescriptor:(AJNMessageArgument*)file fromSender:(NSString *)sender
{
    //
    // GENERATED CODE - DO NOT EDIT
    //
    // Create a category or subclass in separate .h/.m files
    @throw([NSException exceptionWithName:@"NotImplementedException" reason:@"You must override this method in a subclass" userInfo:nil]);
}
- (void)sendDataChunkWithFileID:(AJNMessageArgument*)fileID startByte:(NSNumber*)startByte length:(NSNumber*)chunkLength andFileChunk:(AJNMessageArgument*)chunk inSession:(AJNSessionId)sessionId toDestination:(NSString*)destinationPath

{
    
    self.busObject->SenddataChunk([fileID msgArg], [startByte intValue], [chunkLength intValue], [chunk msgArg], [destinationPath UTF8String], sessionId);
        
}
- (void)sendStopDataXferWithFileID:(AJNMessageArgument*)fileID inSession:(AJNSessionId)sessionId toDestination:(NSString*)destinationPath

{
    
    self.busObject->SendstopDataXfer([fileID msgArg], [destinationPath UTF8String], sessionId);
        
}
- (void)sendDataXferCancelledWithFileID:(AJNMessageArgument*)fileID inSession:(AJNSessionId)sessionId toDestination:(NSString*)destinationPath

{
    
    self.busObject->SenddataXferCancelled([fileID msgArg], [destinationPath UTF8String], sessionId);
        
}
- (void)sendAnnounceWithFileList:(AJNMessageArgument*)fileList andIsFileIDResponse:(BOOL)isFileIDResponse inSession:(AJNSessionId)sessionId toDestination:(NSString*)destinationPath

{
    
    self.busObject->Sendannounce([fileList msgArg], (isFileIDResponse == YES ? true : false), [destinationPath UTF8String], sessionId);
        
}
- (void)sendrequestAnnouncementInSession:(AJNSessionId)sessionId toDestination:(NSString*)destinationPath

{
    
    self.busObject->SendrequestAnnouncement([destinationPath UTF8String], sessionId);
        
}

    
@end

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//  Objective-C Proxy Bus Object implementation for FileTransferBusObject
//
////////////////////////////////////////////////////////////////////////////////

@interface FileTransferBusObjectProxy(Private)

@property (nonatomic, strong) AJNBusAttachment *bus;

- (ProxyBusObject*)proxyBusObject;

@end

@implementation FileTransferBusObjectProxy
    
- (NSNumber*)requestDataWithFileID:(AJNMessageArgument*)fileID startByte:(NSNumber*)startByte length:(NSNumber*)length andMaxChunkLength:(NSNumber*)maxChunkLength
{
    [self addInterfaceNamed:@"org.alljoyn.Cops.DataTransfer"];
    
    // prepare the input arguments
    //
    
    Message reply(*((BusAttachment*)self.bus.handle));    
    MsgArg inArgs[4];
    
    inArgs[0] = *[fileID msgArg];
        
    inArgs[1].Set("i", [startByte intValue]);
        
    inArgs[2].Set("i", [length intValue]);
        
    inArgs[3].Set("i", [maxChunkLength intValue]);
        

    // make the function call using the C++ proxy object
    //
    
    QStatus status = self.proxyBusObject->MethodCall("org.alljoyn.Cops.DataTransfer", "requestData", inArgs, 4, reply, 5000);
    if (ER_OK != status) {
        NSLog(@"ERROR: ProxyBusObject::MethodCall on org.alljoyn.Cops.DataTransfer failed. %@", [AJNStatus descriptionForStatusCode:status]);
        
        return nil;
            
    }

    
    // pass the output arguments back to the caller
    //
    
        
    return [NSNumber numberWithInt:reply->GetArg()->v_int32];
        

}

- (NSNumber*)requestOfferWithFilePath:(NSString*)filePath
{
    [self addInterfaceNamed:@"org.alljoyn.Cops.FileDiscovery"];
    
    // prepare the input arguments
    //
    
    Message reply(*((BusAttachment*)self.bus.handle));    
    MsgArg inArgs[1];
    
    inArgs[0].Set("s", [filePath UTF8String]);
        

    // make the function call using the C++ proxy object
    //
    
    QStatus status = self.proxyBusObject->MethodCall("org.alljoyn.Cops.FileDiscovery", "requestOffer", inArgs, 1, reply, 5000);
    if (ER_OK != status) {
        NSLog(@"ERROR: ProxyBusObject::MethodCall on org.alljoyn.Cops.FileDiscovery failed. %@", [AJNStatus descriptionForStatusCode:status]);
        
        return nil;
            
    }

    
    // pass the output arguments back to the caller
    //
    
        
    return [NSNumber numberWithInt:reply->GetArg()->v_int32];
        

}

- (NSNumber*)offerFileWithFileDescriptor:(AJNMessageArgument*)file
{
    [self addInterfaceNamed:@"org.alljoyn.Cops.FileDiscovery"];
    
    // prepare the input arguments
    //
    
    Message reply(*((BusAttachment*)self.bus.handle));    
    MsgArg inArgs[1];
    
    inArgs[0] = *[file msgArg];
        

    // make the function call using the C++ proxy object
    //
    
    QStatus status = self.proxyBusObject->MethodCall("org.alljoyn.Cops.FileDiscovery", "offerFile", inArgs, 1, reply, 5000);
    if (ER_OK != status) {
        NSLog(@"ERROR: ProxyBusObject::MethodCall on org.alljoyn.Cops.FileDiscovery failed. %@", [AJNStatus descriptionForStatusCode:status]);
        
        return nil;
            
    }

    
    // pass the output arguments back to the caller
    //
    
        
    return [NSNumber numberWithInt:reply->GetArg()->v_int32];
        

}

@end

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//
//  C++ Signal Handler implementation for DataTransferDelegate
//
////////////////////////////////////////////////////////////////////////////////

class DataTransferDelegateSignalHandlerImpl : public AJNSignalHandlerImpl
{
private:

    const ajn::InterfaceDescription::Member* dataChunkSignalMember;
    void dataChunkSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg);

    const ajn::InterfaceDescription::Member* stopDataXferSignalMember;
    void stopDataXferSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg);

    const ajn::InterfaceDescription::Member* dataXferCancelledSignalMember;
    void dataXferCancelledSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg);

    
public:
    /**
     * Constructor for the AJN signal handler implementation.
     *
     * @param aDelegate         Objective C delegate called when one of the below virtual functions is called.     
     */    
    DataTransferDelegateSignalHandlerImpl(id<AJNSignalHandler> aDelegate);
    
    virtual void RegisterSignalHandler(ajn::BusAttachment &bus);
    
    virtual void UnregisterSignalHandler(ajn::BusAttachment &bus);
    
    /**
     * Virtual destructor for derivable class.
     */
    virtual ~DataTransferDelegateSignalHandlerImpl();
};


/**
 * Constructor for the AJN signal handler implementation.
 *
 * @param aDelegate         Objective C delegate called when one of the below virtual functions is called.     
 */    
DataTransferDelegateSignalHandlerImpl::DataTransferDelegateSignalHandlerImpl(id<AJNSignalHandler> aDelegate) : AJNSignalHandlerImpl(aDelegate)
{
	dataChunkSignalMember = NULL;
	stopDataXferSignalMember = NULL;
	dataXferCancelledSignalMember = NULL;

}

DataTransferDelegateSignalHandlerImpl::~DataTransferDelegateSignalHandlerImpl()
{
    m_delegate = NULL;
}

void DataTransferDelegateSignalHandlerImpl::RegisterSignalHandler(ajn::BusAttachment &bus)
{
    QStatus status;
    status = ER_OK;
    const ajn::InterfaceDescription* interface = NULL;
    
    ////////////////////////////////////////////////////////////////////////////
    // Register signal handler for signal dataChunk
    //
    interface = bus.GetInterface("org.alljoyn.Cops.DataTransfer");

    if (interface) {
        // Store the dataChunk signal member away so it can be quickly looked up
        dataChunkSignalMember = interface->GetMember("dataChunk");
        assert(dataChunkSignalMember);

        
        // Register signal handler for dataChunk
        status =  bus.RegisterSignalHandler(this,
            static_cast<MessageReceiver::SignalHandler>(&DataTransferDelegateSignalHandlerImpl::dataChunkSignalHandler),
            dataChunkSignalMember,
            NULL);
            
        if (status != ER_OK) {
            NSLog(@"ERROR: Interface DataTransferDelegateSignalHandlerImpl::RegisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
        }
    }
    else {
        NSLog(@"ERROR: org.alljoyn.Cops.DataTransfer not found.");
    }
    ////////////////////////////////////////////////////////////////////////////    

    ////////////////////////////////////////////////////////////////////////////
    // Register signal handler for signal stopDataXfer
    //
    interface = bus.GetInterface("org.alljoyn.Cops.DataTransfer");

    if (interface) {
        // Store the stopDataXfer signal member away so it can be quickly looked up
        stopDataXferSignalMember = interface->GetMember("stopDataXfer");
        assert(stopDataXferSignalMember);

        
        // Register signal handler for stopDataXfer
        status =  bus.RegisterSignalHandler(this,
            static_cast<MessageReceiver::SignalHandler>(&DataTransferDelegateSignalHandlerImpl::stopDataXferSignalHandler),
            stopDataXferSignalMember,
            NULL);
            
        if (status != ER_OK) {
            NSLog(@"ERROR: Interface DataTransferDelegateSignalHandlerImpl::RegisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
        }
    }
    else {
        NSLog(@"ERROR: org.alljoyn.Cops.DataTransfer not found.");
    }
    ////////////////////////////////////////////////////////////////////////////    

    ////////////////////////////////////////////////////////////////////////////
    // Register signal handler for signal dataXferCancelled
    //
    interface = bus.GetInterface("org.alljoyn.Cops.DataTransfer");

    if (interface) {
        // Store the dataXferCancelled signal member away so it can be quickly looked up
        dataXferCancelledSignalMember = interface->GetMember("dataXferCancelled");
        assert(dataXferCancelledSignalMember);

        
        // Register signal handler for dataXferCancelled
        status =  bus.RegisterSignalHandler(this,
            static_cast<MessageReceiver::SignalHandler>(&DataTransferDelegateSignalHandlerImpl::dataXferCancelledSignalHandler),
            dataXferCancelledSignalMember,
            NULL);
            
        if (status != ER_OK) {
            NSLog(@"ERROR: Interface DataTransferDelegateSignalHandlerImpl::RegisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
        }
    }
    else {
        NSLog(@"ERROR: org.alljoyn.Cops.DataTransfer not found.");
    }
    ////////////////////////////////////////////////////////////////////////////    

}

void DataTransferDelegateSignalHandlerImpl::UnregisterSignalHandler(ajn::BusAttachment &bus)
{
    QStatus status;
    status = ER_OK;
    const ajn::InterfaceDescription* interface = NULL;
    
    ////////////////////////////////////////////////////////////////////////////
    // Unregister signal handler for signal dataChunk
    //
    interface = bus.GetInterface("org.alljoyn.Cops.DataTransfer");
    
    // Store the dataChunk signal member away so it can be quickly looked up
    dataChunkSignalMember = interface->GetMember("dataChunk");
    assert(dataChunkSignalMember);
    
    // Unregister signal handler for dataChunk
    status =  bus.UnregisterSignalHandler(this,
        static_cast<MessageReceiver::SignalHandler>(&DataTransferDelegateSignalHandlerImpl::dataChunkSignalHandler),
        dataChunkSignalMember,
        NULL);
        
    if (status != ER_OK) {
        NSLog(@"ERROR:DataTransferDelegateSignalHandlerImpl::UnregisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
    }
    ////////////////////////////////////////////////////////////////////////////    

    ////////////////////////////////////////////////////////////////////////////
    // Unregister signal handler for signal stopDataXfer
    //
    interface = bus.GetInterface("org.alljoyn.Cops.DataTransfer");
    
    // Store the stopDataXfer signal member away so it can be quickly looked up
    stopDataXferSignalMember = interface->GetMember("stopDataXfer");
    assert(stopDataXferSignalMember);
    
    // Unregister signal handler for stopDataXfer
    status =  bus.UnregisterSignalHandler(this,
        static_cast<MessageReceiver::SignalHandler>(&DataTransferDelegateSignalHandlerImpl::stopDataXferSignalHandler),
        stopDataXferSignalMember,
        NULL);
        
    if (status != ER_OK) {
        NSLog(@"ERROR:DataTransferDelegateSignalHandlerImpl::UnregisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
    }
    ////////////////////////////////////////////////////////////////////////////    

    ////////////////////////////////////////////////////////////////////////////
    // Unregister signal handler for signal dataXferCancelled
    //
    interface = bus.GetInterface("org.alljoyn.Cops.DataTransfer");
    
    // Store the dataXferCancelled signal member away so it can be quickly looked up
    dataXferCancelledSignalMember = interface->GetMember("dataXferCancelled");
    assert(dataXferCancelledSignalMember);
    
    // Unregister signal handler for dataXferCancelled
    status =  bus.UnregisterSignalHandler(this,
        static_cast<MessageReceiver::SignalHandler>(&DataTransferDelegateSignalHandlerImpl::dataXferCancelledSignalHandler),
        dataXferCancelledSignalMember,
        NULL);
        
    if (status != ER_OK) {
        NSLog(@"ERROR:DataTransferDelegateSignalHandlerImpl::UnregisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
    }
    ////////////////////////////////////////////////////////////////////////////    

}


void DataTransferDelegateSignalHandlerImpl::dataChunkSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg)
{
    @autoreleasepool {
        
    AJNMessageArgument* inArg0 = [[AJNMessageArgument alloc] initWithHandle:(AJNHandle)new MsgArg(*(msg->GetArg(0))) shouldDeleteHandleOnDealloc:YES];        
        
    int32_t inArg1 = msg->GetArg(1)->v_int32;
        
    int32_t inArg2 = msg->GetArg(2)->v_int32;
        
    AJNMessageArgument* inArg3 = [[AJNMessageArgument alloc] initWithHandle:(AJNHandle)new MsgArg(*(msg->GetArg(3))) shouldDeleteHandleOnDealloc:YES];        
        
        NSString *from = [NSString stringWithCString:msg->GetSender() encoding:NSUTF8StringEncoding];
        NSString *objectPath = [NSString stringWithCString:msg->GetObjectPath() encoding:NSUTF8StringEncoding];
        AJNSessionId sessionId = msg->GetSessionId();        
        //NSLog(@"Received dataChunk signal from %@ on path %@ for session id %u [%s > %s]", from, objectPath, msg->GetSessionId(), msg->GetRcvEndpointName(), msg->GetDestination() ? msg->GetDestination() : "broadcast");
        //NSLog(@"dataChunk startByte %u length %u", inArg1, inArg2);
        dispatch_async(dispatch_get_main_queue(), ^{
            
            [(id<DataTransferDelegateSignalHandler>)m_delegate didReceiveDataChunkWithFileID:inArg0 startByte:[NSNumber numberWithInt:inArg1] length:[NSNumber numberWithInt:inArg2] andFileChunk:inArg3 inSession:sessionId fromSender:from];
                
        });
        
    }
}

void DataTransferDelegateSignalHandlerImpl::stopDataXferSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg)
{
    @autoreleasepool {
        
    AJNMessageArgument* inArg0 = [[AJNMessageArgument alloc] initWithHandle:(AJNHandle)new MsgArg(*(msg->GetArg(0))) shouldDeleteHandleOnDealloc:YES];        
        
        NSString *from = [NSString stringWithCString:msg->GetSender() encoding:NSUTF8StringEncoding];
        NSString *objectPath = [NSString stringWithCString:msg->GetObjectPath() encoding:NSUTF8StringEncoding];
        AJNSessionId sessionId = msg->GetSessionId();        
        NSLog(@"Received stopDataXfer signal from %@ on path %@ for session id %u [%s > %s]", from, objectPath, msg->GetSessionId(), msg->GetRcvEndpointName(), msg->GetDestination() ? msg->GetDestination() : "broadcast");
        
        dispatch_async(dispatch_get_main_queue(), ^{
            
            [(id<DataTransferDelegateSignalHandler>)m_delegate didReceiveStopDataXferWithFileID:inArg0 inSession:sessionId fromSender:from];
                
        });
        
    }
}

void DataTransferDelegateSignalHandlerImpl::dataXferCancelledSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg)
{
    @autoreleasepool {
        
    AJNMessageArgument* inArg0 = [[AJNMessageArgument alloc] initWithHandle:(AJNHandle)new MsgArg(*(msg->GetArg(0))) shouldDeleteHandleOnDealloc:YES];        
        
        NSString *from = [NSString stringWithCString:msg->GetSender() encoding:NSUTF8StringEncoding];
        NSString *objectPath = [NSString stringWithCString:msg->GetObjectPath() encoding:NSUTF8StringEncoding];
        AJNSessionId sessionId = msg->GetSessionId();        
        NSLog(@"Received dataXferCancelled signal from %@ on path %@ for session id %u [%s > %s]", from, objectPath, msg->GetSessionId(), msg->GetRcvEndpointName(), msg->GetDestination() ? msg->GetDestination() : "broadcast");
        
        dispatch_async(dispatch_get_main_queue(), ^{
            
            [(id<DataTransferDelegateSignalHandler>)m_delegate didReceiveDataXferCancelledWithFileID:inArg0 inSession:sessionId fromSender:from];
                
        });
        
    }
}


@implementation AJNBusAttachment(DataTransferDelegate)

- (void)registerDataTransferDelegateSignalHandler:(id<DataTransferDelegateSignalHandler>)signalHandler
{
    DataTransferDelegateSignalHandlerImpl *signalHandlerImpl = new DataTransferDelegateSignalHandlerImpl(signalHandler);
    signalHandler.handle = signalHandlerImpl;
    [self registerSignalHandler:signalHandler];
}

@end

////////////////////////////////////////////////////////////////////////////////
    
////////////////////////////////////////////////////////////////////////////////
//
//  C++ Signal Handler implementation for FileDiscoveryDelegate
//
////////////////////////////////////////////////////////////////////////////////

class FileDiscoveryDelegateSignalHandlerImpl : public AJNSignalHandlerImpl
{
private:

    const ajn::InterfaceDescription::Member* announceSignalMember;
    void announceSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg);

    const ajn::InterfaceDescription::Member* requestAnnouncementSignalMember;
    void requestAnnouncementSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg);

    
public:
    /**
     * Constructor for the AJN signal handler implementation.
     *
     * @param aDelegate         Objective C delegate called when one of the below virtual functions is called.     
     */    
    FileDiscoveryDelegateSignalHandlerImpl(id<AJNSignalHandler> aDelegate);
    
    virtual void RegisterSignalHandler(ajn::BusAttachment &bus);
    
    virtual void UnregisterSignalHandler(ajn::BusAttachment &bus);
    
    /**
     * Virtual destructor for derivable class.
     */
    virtual ~FileDiscoveryDelegateSignalHandlerImpl();
};


/**
 * Constructor for the AJN signal handler implementation.
 *
 * @param aDelegate         Objective C delegate called when one of the below virtual functions is called.     
 */    
FileDiscoveryDelegateSignalHandlerImpl::FileDiscoveryDelegateSignalHandlerImpl(id<AJNSignalHandler> aDelegate) : AJNSignalHandlerImpl(aDelegate)
{
	announceSignalMember = NULL;
	requestAnnouncementSignalMember = NULL;

}

FileDiscoveryDelegateSignalHandlerImpl::~FileDiscoveryDelegateSignalHandlerImpl()
{
    m_delegate = NULL;
}

void FileDiscoveryDelegateSignalHandlerImpl::RegisterSignalHandler(ajn::BusAttachment &bus)
{
    QStatus status;
    status = ER_OK;
    const ajn::InterfaceDescription* interface = NULL;
    
    ////////////////////////////////////////////////////////////////////////////
    // Register signal handler for signal announce
    //
    interface = bus.GetInterface("org.alljoyn.Cops.FileDiscovery");

    if (interface) {
        // Store the announce signal member away so it can be quickly looked up
        announceSignalMember = interface->GetMember("announce");
        assert(announceSignalMember);

        
        // Register signal handler for announce
        status =  bus.RegisterSignalHandler(this,
            static_cast<MessageReceiver::SignalHandler>(&FileDiscoveryDelegateSignalHandlerImpl::announceSignalHandler),
            announceSignalMember,
            NULL);
            
        if (status != ER_OK) {
            NSLog(@"ERROR: Interface FileDiscoveryDelegateSignalHandlerImpl::RegisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
        }
    }
    else {
        NSLog(@"ERROR: org.alljoyn.Cops.FileDiscovery not found.");
    }
    ////////////////////////////////////////////////////////////////////////////    

    ////////////////////////////////////////////////////////////////////////////
    // Register signal handler for signal requestAnnouncement
    //
    interface = bus.GetInterface("org.alljoyn.Cops.FileDiscovery");

    if (interface) {
        // Store the requestAnnouncement signal member away so it can be quickly looked up
        requestAnnouncementSignalMember = interface->GetMember("requestAnnouncement");
        assert(requestAnnouncementSignalMember);

        
        // Register signal handler for requestAnnouncement
        status =  bus.RegisterSignalHandler(this,
            static_cast<MessageReceiver::SignalHandler>(&FileDiscoveryDelegateSignalHandlerImpl::requestAnnouncementSignalHandler),
            requestAnnouncementSignalMember,
            NULL);
            
        if (status != ER_OK) {
            NSLog(@"ERROR: Interface FileDiscoveryDelegateSignalHandlerImpl::RegisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
        }
    }
    else {
        NSLog(@"ERROR: org.alljoyn.Cops.FileDiscovery not found.");
    }
    ////////////////////////////////////////////////////////////////////////////    

}

void FileDiscoveryDelegateSignalHandlerImpl::UnregisterSignalHandler(ajn::BusAttachment &bus)
{
    QStatus status;
    status = ER_OK;
    const ajn::InterfaceDescription* interface = NULL;
    
    ////////////////////////////////////////////////////////////////////////////
    // Unregister signal handler for signal announce
    //
    interface = bus.GetInterface("org.alljoyn.Cops.FileDiscovery");
    
    // Store the announce signal member away so it can be quickly looked up
    announceSignalMember = interface->GetMember("announce");
    assert(announceSignalMember);
    
    // Unregister signal handler for announce
    status =  bus.UnregisterSignalHandler(this,
        static_cast<MessageReceiver::SignalHandler>(&FileDiscoveryDelegateSignalHandlerImpl::announceSignalHandler),
        announceSignalMember,
        NULL);
        
    if (status != ER_OK) {
        NSLog(@"ERROR:FileDiscoveryDelegateSignalHandlerImpl::UnregisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
    }
    ////////////////////////////////////////////////////////////////////////////    

    ////////////////////////////////////////////////////////////////////////////
    // Unregister signal handler for signal requestAnnouncement
    //
    interface = bus.GetInterface("org.alljoyn.Cops.FileDiscovery");
    
    // Store the requestAnnouncement signal member away so it can be quickly looked up
    requestAnnouncementSignalMember = interface->GetMember("requestAnnouncement");
    assert(requestAnnouncementSignalMember);
    
    // Unregister signal handler for requestAnnouncement
    status =  bus.UnregisterSignalHandler(this,
        static_cast<MessageReceiver::SignalHandler>(&FileDiscoveryDelegateSignalHandlerImpl::requestAnnouncementSignalHandler),
        requestAnnouncementSignalMember,
        NULL);
        
    if (status != ER_OK) {
        NSLog(@"ERROR:FileDiscoveryDelegateSignalHandlerImpl::UnregisterSignalHandler failed. %@", [AJNStatus descriptionForStatusCode:status] );
    }
    ////////////////////////////////////////////////////////////////////////////    

}


void FileDiscoveryDelegateSignalHandlerImpl::announceSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg)
{
    @autoreleasepool {
        
    AJNMessageArgument* inArg0 = [[AJNMessageArgument alloc] initWithHandle:(AJNHandle)new MsgArg(*(msg->GetArg(0))) shouldDeleteHandleOnDealloc:YES];        
        
    bool inArg1 = msg->GetArg(1)->v_bool;
        
        NSString *from = [NSString stringWithCString:msg->GetSender() encoding:NSUTF8StringEncoding];
        NSString *objectPath = [NSString stringWithCString:msg->GetObjectPath() encoding:NSUTF8StringEncoding];
        AJNSessionId sessionId = msg->GetSessionId();        
        NSLog(@"Received announce signal from %@ on path %@ for session id %u [%s > %s]", from, objectPath, msg->GetSessionId(), msg->GetRcvEndpointName(), msg->GetDestination() ? msg->GetDestination() : "broadcast");
        
        dispatch_async(dispatch_get_main_queue(), ^{
            
            [(id<FileDiscoveryDelegateSignalHandler>)m_delegate didReceiveAnnounceWithFileList:inArg0 andIsFileIDResponse:(inArg1 ? YES : NO) inSession:sessionId fromSender:from];
                
        });
        
    }
}

void FileDiscoveryDelegateSignalHandlerImpl::requestAnnouncementSignalHandler(const ajn::InterfaceDescription::Member* member, const char* srcPath, ajn::Message& msg)
{
    @autoreleasepool {
        
        NSString *from = [NSString stringWithCString:msg->GetSender() encoding:NSUTF8StringEncoding];
        NSString *objectPath = [NSString stringWithCString:msg->GetObjectPath() encoding:NSUTF8StringEncoding];
        AJNSessionId sessionId = msg->GetSessionId();        
        NSLog(@"Received requestAnnouncement signal from %@ on path %@ for session id %u [%s > %s]", from, objectPath, msg->GetSessionId(), msg->GetRcvEndpointName(), msg->GetDestination() ? msg->GetDestination() : "broadcast");
        
        dispatch_async(dispatch_get_main_queue(), ^{
            
            [(id<FileDiscoveryDelegateSignalHandler>)m_delegate didReceiverequestAnnouncementInSession:sessionId fromSender:from];
                
        });
        
    }
}


@implementation AJNBusAttachment(FileDiscoveryDelegate)

- (void)registerFileDiscoveryDelegateSignalHandler:(id<FileDiscoveryDelegateSignalHandler>)signalHandler
{
    FileDiscoveryDelegateSignalHandlerImpl *signalHandlerImpl = new FileDiscoveryDelegateSignalHandlerImpl(signalHandler);
    signalHandler.handle = signalHandlerImpl;
    [self registerSignalHandler:signalHandler];
}

@end

////////////////////////////////////////////////////////////////////////////////
    
